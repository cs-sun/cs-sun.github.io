<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>When Graphs Meet Agents: Orchestration, Topology, and the Uncharted Territory of Safety - Sun Changsheng</title>
    <meta name="description" content="A deep dive into the emerging intersection of graph structures and LLM agentic systems, exploring orchestration frameworks, topology-aware design, and the largely unexplored frontier of topology-based security.">

    <!-- Blog styles -->
    <link rel="stylesheet" href="../blog.css">

    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\[', right: '\\]', display: true},
                {left: '\\(', right: '\\)', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <nav class="blog-nav">
        <a href="../index.html">&larr; about me</a>
        <a href="index.html">&larr; all posts</a>
    </nav>

    <article class="blog-post">
        <header class="post-header">
            <h1>When Graphs Meet Agents: Orchestration, Topology, and the Uncharted Territory of Safety</h1>
            <div class="post-meta">
                <time datetime="2026-02-09">09 February 2026</time>
                <span class="meta-separator">•</span>
                <span class="post-author">Sun Changsheng</span>
            </div>
        </header>

        <div class="post-content">
            <!-- [TOC] -->

<h1 id="why-graphs">Why Graphs?</h1>
<p>If you squint at any sufficiently complex LLM agent system — one that plans, decomposes tasks, dispatches tool calls, and synthesizes results — you'll notice it's a graph. Not metaphorically. Literally. There are nodes (tasks, agents, LLM calls) and edges (dependencies, information flow, communication channels). The question is whether we should treat this graph structure as an incidental implementation detail or as a first-class object worthy of optimization, analysis, and — crucially — adversarial scrutiny.</p>
<p>Over the past two years, a growing body of work has chosen the latter. Papers like <strong>LLMCompiler</strong> (<a href="#ref-llmcompiler">Kim et al., 2024</a>), <strong>GPTSwarm</strong> (<a href="#ref-gptswarm">Zhuge et al., 2024</a>), and <strong>LocAgent</strong> (<a href="#ref-locagent">2025</a>) explicitly construct, manipulate, and optimize graph structures to orchestrate agentic behavior. Meanwhile, a parallel (and largely disconnected) literature has been studying how to attack and defend LLM agents — prompt injections, jailbreak propagation, tool misuse. But here's what struck me: almost nobody is asking what happens when you attack the <em>graph itself</em>. Not the prompts flowing through edges, but the topology, the wiring, the structure of who-talks-to-whom and which-task-depends-on-which.</p>
<p>This post is my attempt to map the landscape at this intersection: how graphs are used in agentic AI, what we know about how topology affects both performance and safety, and where the most promising (and most vacant) research real estate lies.</p>
<h1 id="the-rise-of-graph-based-orchestration">The Rise of Graph-Based Orchestration</h1>
<h2 id="dags-as-the-backbone-of-parallel-execution">DAGs as the Backbone of Parallel Execution</h2>
<p>The simplest and most intuitive use of graphs in agentic systems is to model task dependencies as directed acyclic graphs (DAGs). If task B depends on the output of task A, but task C is independent of both, a DAG captures this cleanly and enables parallel execution of A and C.</p>
<p><strong>LLMCompiler</strong> (<a href="#ref-llmcompiler">Kim et al., 2024</a>) was among the first to formalize this idea for LLM function calling. The architecture is elegant: a planner LLM generates a task dependency DAG, a dispatcher executes tasks in topological order (parallelizing independent branches), and a joiner synthesizes results. The payoff is substantial — 3.7× latency speedup and up to 1.35× accuracy improvement over ReAct-style sequential execution on benchmarks. The key insight is that many real-world queries contain inherent parallelism that sequential chain-of-thought reasoning wastes.</p>
<p><strong>StateFlow</strong> (<a href="#ref-stateflow">Wu et al., 2024</a>) takes a complementary angle, modeling agentic workflows as finite state machines — a special case of directed graphs where nodes represent execution states and edges represent transitions. This formulation is less about parallelism and more about <em>control</em>: by explicitly defining legal state transitions, StateFlow constrains the agent's behavior in ways that free-form prompting cannot. The results bear this out: 13–28% higher success rates than ReAct at 3–5× lower cost. I find this particularly interesting because it highlights a tension that runs through the entire field: expressiveness vs. controllability. The more structure you impose on the execution graph, the less you rely on the LLM to "figure it out" — and the more predictable (and verifiable) the system becomes.</p>
<p>For scenarios where task dependencies evolve during execution, <strong>DynTaskMAS</strong> (<a href="#ref-dyntaskmas">2025</a>) introduced continuously-updated dynamic task DAGs for asynchronous multi-agent execution. And on the automated design front, <strong>AFlow</strong> (<a href="#ref-aflow">Zhang et al., 2025a</a>) uses Monte Carlo Tree Search over two-level graph abstractions to automatically generate workflow graphs, removing humans from the loop of pipeline design entirely.</p>
<h2 id="agents-as-computational-graphs">Agents as Computational Graphs</h2>
<p>A more radical perspective — and one I think has deeper implications — is to treat the entire agent system as a <em>differentiable computational graph</em>. <strong>GPTSwarm</strong> (<a href="#ref-gptswarm">Zhuge et al., 2024</a>), presented as an oral at ICML 2024, unifies diverse agent paradigms under this framework. Chain-of-Thought, Tree-of-Thought, Reflexion — these aren't different algorithms so much as different <em>graph topologies</em> over LLM-invoked functions. Nodes are operations (LLM calls, tool invocations, aggregation functions), and edges carry information between them. The punchline: you can optimize the edge weights via reinforcement learning, and the system discovers high-performance configurations that resemble — or improve upon — hand-designed agent architectures.</p>
<p>Why does this matter? Because it shifts agent design from a craft (prompt engineering, hand-coded pipelines) to a <em>search problem over graph space</em>. And once you're searching over graph space, all the machinery of graph optimization, graph neural networks, and — yes — graph adversarial robustness becomes directly applicable.</p>
<h2 id="domain-specific-graph-agents">Domain-Specific Graph Agents</h2>
<p>Among the papers I've been reading, <strong>LocAgent</strong> (<a href="#ref-locagent">2025</a>) stands out for how cleanly it demonstrates the value of explicit graph structure. The task is code localization — given a bug report, find the relevant files and functions in a large codebase. LocAgent constructs a directed heterogeneous graph over the codebase with four edge types: <em>contain</em>, <em>import</em>, <em>invoke</em>, and <em>inherit</em>. Agents are then equipped with graph traversal tools for multi-hop dependency reasoning. The result: 92.7% file-level localization accuracy at 86% cost reduction on SWE-bench-Lite. The graph here isn't just scaffolding; it encodes domain knowledge about code structure that would be expensive and unreliable to recover from raw text alone.</p>
<p><strong>OpenHands</strong> (<a href="#ref-openhands">Wang et al., 2025a</a>), the open-source agentic coding platform (formerly OpenDevin), takes a different architectural path. Rather than explicit graph scheduling, it uses an event stream architecture with hierarchical agent delegation — tree-like in structure, but without formal graph-based optimization. This is representative of many production systems: they <em>implicitly</em> create graph structures through delegation and composition, even if the graph is never explicitly constructed or analyzed.</p>
<h2 id="what-production-deployments-taught-us">What Production Deployments Taught Us</h2>
<p>I want to pause on a piece of practical wisdom that I think is under-appreciated in the academic literature. <strong>Atlassian's engineering team</strong>, in deploying their Rovo Chat multi-agent system (<a href="#ref-atlassian">Atlassian, 2025</a>), found that single-shot DAG planning from user queries is <em>brittle</em>. Their initial approach — have an LLM look at the user query and output a complete execution DAG — worked well on clean benchmarks but fell apart on the messy, ambiguous queries real users produce. They reverted to hybrid orchestrators that combine graph-based scheduling with fallback heuristics.</p>
<p>This suggests something important: DAG orchestration may be better suited for <em>post-training optimization</em> (where you have time to search over graph structures, as in AFlow or GPTSwarm) than for <em>runtime planning</em> (where a single LLM call must produce a correct DAG from an ambiguous query). It's a lesson about the difference between the graph as a <em>design artifact</em> vs. the graph as a <em>runtime prediction</em>.</p>
<h1 id="does-the-shape-of-the-graph-matter">Does the Shape of the Graph Matter?</h1>
<p>This is perhaps the most fundamental question in graph-based agentic AI, and the answer turns out to be both "yes, enormously" and "it's complicated."</p>
<h2 id="no-topology-rules-them-all">No Topology Rules Them All</h2>
<p><strong>MacNet</strong> (<a href="#ref-macnet">Qian et al., 2025</a>), accepted at ICLR 2025, conducted the first systematic comparison of communication topologies for multi-agent LLM collaboration. They tested an impressive array: chain, tree, star, binary tree, mesh, layered, random, and complete graph configurations, across heterogeneous tasks including software development, logical reasoning, and math.</p>
<p>The headline finding: <strong>no single topology is universally optimal</strong>. Chains excel for software development (where sequential refinement matters), while mesh topologies dominate logical selection tasks (where diverse perspectives help). This isn't entirely surprising — it mirrors findings in distributed systems and organizational theory — but the paper quantifies it rigorously. MacNet also discovered a <em>collaborative scaling law</em> following logistic growth: collaborative emergence (where multi-agent systems start outperforming single agents) occurs at smaller scales than neural emergence (where bigger models start showing qualitative improvements). This is encouraging — it suggests you don't need hundreds of agents to see benefits from topology design.</p>
<h2 id="learning-the-right-topology-with-gnns">Learning the Right Topology with GNNs</h2>
<p>If no fixed topology works everywhere, the natural next step is to <em>learn</em> the topology. <strong>G-Designer</strong> (<a href="#ref-gdesigner">Zhang et al., 2025b</a>), accepted at ICML 2025, does exactly this using a variational graph auto-encoder (VGAE). Given a task description, G-Designer predicts the optimal agent communication graph — which agents should talk to whom, and with what connectivity pattern. It consistently outperforms static hand-crafted topologies, achieving up to 95% token reduction (!) while maintaining accuracy. The token reduction is particularly noteworthy: not only does the learned topology perform better, but it communicates <em>far less</em>, because it routes information only where it's needed.</p>
<p>More recently, <strong>Guided Topology Diffusion (GTD)</strong> (<a href="#ref-gtd">2025</a>) applied conditional discrete graph diffusion with a Graph Transformer denoiser to generate communication graphs, achieving Pareto-optimal accuracy-cost tradeoffs. <strong>Assemble Your Crew</strong> (<a href="#ref-assemblecrew">2025</a>) further advances this line with autoregressive graph generation for topology design. The trend is clear: topology design is moving from hand-crafted to learned, and GNNs are the method of choice.</p>
<p>I want to emphasize something that often gets lost in the method details: these papers are demonstrating that <em>the structure of agent interaction matters as much as the content</em>. You can have the best LLM in the world, but if you wire it into a suboptimal communication topology, you'll get suboptimal results. This is a fundamentally graph-theoretic insight.</p>
<h2 id="gnns-can-predict-whether-your-workflow-will-succeed">GNNs Can Predict Whether Your Workflow Will Succeed</h2>
<p>A pivotal bridging result — and one that I think opens the door to a whole class of new research — comes from <strong>FLORA-Bench</strong> (<a href="#ref-florabench">Zhang et al., 2025c</a>). This paper asks a deceptively simple question: if you represent an agentic workflow as a computational DAG, can a GNN predict whether it will succeed?</p>
<p>The answer is yes, with &gt;0.8 accuracy across different LLM backends (GPT-4o-mini, DeepSeek V3, Qwen 7B). Standard GNN architectures — GCN, GAT, GCNII, Graph Transformer — all work, and they significantly outperform LLMs that are given serialized text descriptions of the same workflows. <strong>GLOW</strong> (<a href="#ref-glow">2025</a>) extends this further by integrating GNN structural inductive bias with LLM semantic expressiveness, reaching 99.1% workflow parsing accuracy.</p>
<p>Why do I consider this a pivotal result? Because it establishes that <strong>GNNs are already processing agentic workflow graphs as their native input</strong>. This means the entire toolkit of GNN robustness, GNN explainability, and GNN adversarial attacks becomes <em>directly applicable</em> — not through some forced analogy, but through the natural problem formulation. If a GNN predicts your workflow will succeed, you can ask: <em>how robust is that prediction to small perturbations of the graph?</em> And nobody, as far as I can tell, has asked that question yet.</p>
<h1 id="the-security-landscape-mostly-content-rarely-structure">The Security Landscape: Mostly Content, Rarely Structure</h1>
<p>The LLM agent security literature has grown explosively, but if you read it carefully, you'll notice a pattern: almost all attacks target <em>content</em> (prompts, messages, tool inputs), and almost all defenses operate on <em>content</em> (output filtering, input sanitization, safety classifiers). The graph structure — the wiring of the system — is treated as immutable background.</p>
<h2 id="how-agents-get-attacked">How Agents Get Attacked</h2>
<p>The attack surface of multi-agent LLM systems is larger than most people realize. <strong>Agent Smith</strong> (<a href="#ref-agentsmith">Gu et al., 2024</a>), presented at ICML 2024, demonstrated something genuinely alarming: a single adversarial image injected into one agent can trigger <em>exponentially fast</em> jailbreak propagation across an entire multi-agent network. The mechanism is viral — compromised agents produce adversarial outputs that compromise their neighbors, who in turn compromise <em>their</em> neighbors. The exponential growth rate means that by the time you detect the attack, most of the network may already be compromised.</p>
<p><strong>Prompt Infection</strong> (<a href="#ref-promptinfection">2024</a>) studied self-replicating prompt injections that spread between communicating agents. The <strong>TAMAS</strong> benchmark (<a href="#ref-tamas">2025</a>) systematically evaluates six attack types — including Byzantine agents (which behave arbitrarily) and colluding agents (which coordinate their attacks) — across centralized, decentralized, and swarm configurations. <strong>Agent Security Bench (ASB)</strong> (<a href="#ref-asb">2025</a>), at ICLR 2025, provides the most comprehensive evaluation to date: 27 attack/defense methods across ~90K test cases, with maximum attack success rates reaching 84.30%.</p>
<p>And these aren't just theoretical concerns. <strong>OpenHands</strong>, one of the most popular open-source agentic platforms, suffered two critical exploits in 2025: a zero-click data exfiltration attack where an adversarial image could steal <code>GITHUB_TOKEN</code> values via URL parameters (<a href="#ref-openhands-exfil">Embrace The Red, 2025a</a>), and a remote code execution exploit where untrusted web data could hijack the agent to connect to attacker-controlled servers (<a href="#ref-openhands-rce">Embrace The Red, 2025b</a>). Browser agent testing found OpenHands executed harmful behaviors in 67 out of 100 test cases without guardrails (<a href="#ref-invariant">Invariant Labs, 2025</a>).</p>
<h2 id="defenses-from-guardrails-to-formal-guarantees">Defenses: From Guardrails to Formal Guarantees</h2>
<p>Defense approaches span a wide spectrum of rigor. At the formal end, <strong>CaMeL</strong> (<a href="#ref-camel">Debenedetti et al., 2025</a>) from Google DeepMind offers <em>provable</em> security against prompt injection. The key idea is elegant: extract control-flow and data-flow graphs from the <em>trusted</em> query (what the user actually asked for), then enforce at runtime that untrusted data (web pages, tool outputs, etc.) can never influence program flow. If the data-flow graph shows that an untrusted string would be used in a control decision, CaMeL blocks it. This achieves provable security on the AgentDojo benchmark.</p>
<p>A companion paper on <strong>Design Patterns for Securing LLM Agents</strong> (<a href="#ref-designpatterns">Asan et al., 2025</a>) from IBM/ETH/Google/Microsoft proposes six architectural patterns — Plan-then-Execute, LLM Map-Reduce, Dual LLM — that constrain the workflow graph to resist prompt injection <em>by construction</em>. I find this approach compelling because it shifts security from an afterthought (add a filter) to a <em>structural property</em> of the workflow graph itself.</p>
<p>Other notable defenses include <strong>TrustAgent</strong> (<a href="#ref-trustagent">Hua et al., 2024</a>), which introduced an "Agent Constitution" with pre-planning, in-planning, and post-planning safety checks; <strong>VeriGuard</strong> (<a href="#ref-veriguard">2025</a>), which applied Hoare-triple-based formal verification to individual agent actions; and <strong>AgentSpec</strong> (<a href="#ref-agentspec">2026</a>), which provides a domain-specific language for runtime safety rule enforcement.</p>
<p>On the LLM capability side, <strong>R-Tuning</strong> (<a href="#ref-rtuning">Zhang et al., 2024</a>), which won the Outstanding Paper award at NAACL 2024, trains LLMs to recognize their knowledge boundaries and say "I don't know." While not graph-related, this capability is directly relevant to agentic safety — an agent that knows when it's uncertain can avoid taking catastrophic actions on shaky reasoning.</p>
<h2 id="when-reasoning-itself-becomes-the-vulnerability">When Reasoning Itself Becomes the Vulnerability</h2>
<p>One paper that sits at an interesting angle to the graph-based perspective is <strong>"The Danger of Overthinking"</strong> (<a href="#ref-overthinking">2025</a>), which identifies the <em>reasoning-action dilemma</em> in agentic tasks. Agents using extended chain-of-thought reasoning can fall into failure modes where excessive reasoning leads to "Rogue Actions" — the agent violates sequential execution constraints, essentially acting before it has finished thinking, or thinking itself into an inconsistent state.</p>
<p>This is deeply relevant to graph-based scheduling. A workflow DAG imposes an execution order — task B shouldn't start before task A finishes. But if an agent within a node can unilaterally decide to skip ahead or re-order operations based on its internal reasoning, the DAG's guarantees are violated from within. It's a reminder that graph-level safety requires not just structural integrity of the DAG, but also behavioral compliance of the agents <em>within</em> each node.</p>
<h1 id="topology-aware-security-a-frontier-with-three-papers">Topology-Aware Security: A Frontier with Three Papers</h1>
<p>Here's the punchline of this survey, and the reason I wrote this post: <strong>the intersection of graph topology and security in multi-agent LLM systems is almost completely unexplored.</strong> I found exactly three papers that directly study how graph structure affects security — and they all come from the same (or closely related) research group.</p>
<h2 id="detecting-attacks-on-the-graph">Detecting Attacks on the Graph</h2>
<p><strong>G-Safeguard</strong> (<a href="#ref-gsafeguard">Wang et al., 2025b</a>), published at ACL 2025, is the single most relevant paper to this intersection. It introduces the first security mechanism that operates <em>on the graph topology</em> of multi-agent systems. The approach has two phases: (1) train an edge-featured GNN to detect anomalous agents by analyzing the multi-agent utterance graph — the graph whose nodes are agents and whose edges carry conversation messages; and (2) perform <em>topological interventions</em> (essentially, graph pruning) to isolate compromised agents and remediate attacks.</p>
<p>The results are promising: G-Safeguard recovers over 40% performance under prompt injection attacks across tree, chain, and graph configurations, with generalizability across different LLM backbones. What I find most interesting is the conceptual framing — the paper demonstrates that adversarial influence leaves <em>structural signatures</em> in the communication graph that a GNN can detect, even when the textual content of messages looks benign to a naive classifier.</p>
<h2 id="which-topologies-are-safer">Which Topologies Are Safer?</h2>
<p><strong>NetSafe</strong> (<a href="#ref-netsafe">Yu et al., 2025</a>), also at ACL 2025, directly studies the relationship between topological properties and safety. The findings are intuitive in retrospect but had not been previously quantified: highly connected networks are more susceptible to adversarial spread (because there are more paths for malicious influence to propagate); star topology performance drops by 29.7% under attack (because the central node is a single point of failure); and networks with greater average distance from the attacker exhibit enhanced safety (because adversarial influence attenuates over multiple hops).</p>
<p>NetSafe also identifies two interesting phenomena: "Agent Hallucination" (agents producing unreliable outputs under adversarial influence from topological neighbors) and "Aggregation Safety" (the degree to which different aggregation strategies — majority vote, weighted average, etc. — amplify or dampen adversarial signals).</p>
<p><strong>MAMA</strong> (<a href="#ref-mama">2024</a>) complements this by studying PII (Personally Identifiable Information) leakage across six canonical topologies: complete, ring, chain, tree, star, and star-ring. The central result aligns with NetSafe: denser connectivity and shorter attacker-target distances increase leakage. Fully connected and star-ring topologies are most vulnerable; chains and trees offer the strongest privacy protection. The topology ordering is preserved across different LLM backbones, suggesting this is a structural property rather than a model-specific artifact.</p>
<p>These three papers together establish a clear principle: <strong>topology is a security-relevant design choice, not just a performance-relevant one.</strong> Choosing a fully connected communication graph for your multi-agent system isn't just wasteful in tokens — it's actively <em>dangerous</em> because it maximizes the attack surface.</p>
<h2 id="risk-aware-composition-almost-there">Risk-Aware Composition: Almost There</h2>
<p>One paper that partially enters the risk-optimization territory deserves special mention. <strong>"Risk-Sensitive Agent Compositions"</strong> (<a href="#ref-risksensitive">2025</a>) formalizes agentic workflows as DAGs called "agent graphs" where edges represent agents and paths represent feasible compositions. It then minimizes Value-at-Risk (VaR) of loss distributions encoding safety, fairness, and privacy violations.</p>
<p>This is conceptually close to what I think the field needs, but it stops short in several ways: it uses VaR rather than CVaR (Conditional Value-at-Risk, which better captures tail risk), it doesn't employ distributionally robust optimization (DRO), and it doesn't leverage GNN-based workflow prediction. There's a natural extension here that combines the GNN workflow predictors from FLORA-Bench with CVaR-based risk optimization — but nobody has done it yet.</p>
<h1 id="whats-missing-research-gaps-i-find-exciting">What's Missing: Research Gaps I Find Exciting</h1>
<p>After reading through this literature, I'm struck by how wide the gaps are. Here are the directions that seem most promising to me, roughly ordered by how excited I am about them.</p>
<p><strong>Certified robustness of workflow graphs.</strong> We have certified robustness methods for GNNs — randomized smoothing on graphs, spectral certificates, certified perturbation bounds. We have GNNs that predict agentic workflow performance (FLORA-Bench, GLOW). Nobody has connected the two. The question "if I add or remove $k$ edges from this workflow DAG, is the GNN's performance prediction still valid?" is both well-defined and practically important, and it has never been asked.</p>
<p><strong>Adversarial structural attacks on workflow DAGs.</strong> The graph adversarial robustness community has a mature toolkit of structural attacks — Metattack, Nettack, PGD on graph structure. The question "how many edge perturbations does it take to make a workflow DAG fail?" is the agentic-AI analog of these attacks. This would reveal which workflow structures are inherently fragile and which are robust — information that's critical for deploying agentic systems in high-stakes settings.</p>
<p><strong>GNN-explainable agent orchestration.</strong> If GNNs can predict whether a workflow will succeed, the natural follow-up is: <em>which substructures drive that prediction?</em> Applying GNNExplainer, SubgraphX, or concept-based graph explanations to workflow predictors would tell us which parts of a workflow DAG are critical for success and which are redundant. This has both debugging applications (why did this workflow fail?) and security applications (which substructures, if perturbed, would cause failure?).</p>
<p><strong>CVaR/DRO-optimized workflow graphs.</strong> The risk-sensitive agent compositions paper uses VaR, but CVaR (expected tail loss) is a more appropriate risk measure for safety-critical systems because it accounts for the <em>severity</em> of worst-case outcomes, not just their probability. Combining CVaR optimization with GNN-predicted workflow performance under distributional uncertainty (Wasserstein ambiguity sets, for instance) would yield workflows that are provably robust under worst-case distributional shifts.</p>
<p><strong>Directed vs. undirected graph impact on safety.</strong> Here's a subtle but important gap: all the topology-safety papers (G-Safeguard, NetSafe, MAMA) study <em>communication graphs</em>, which are typically undirected or bidirectional (agent A can message agent B, and vice versa). But workflow DAGs — the task dependency structures — are <em>directed</em> and <em>acyclic</em>. The directional constraint fundamentally changes the attack surface: in a DAG, adversarial influence can only propagate forward (downstream), not backward. This asymmetry hasn't been studied, and it likely has significant implications for defense design.</p>
<p><strong>Formal verification of workflow DAGs.</strong> VeriPlan (<a href="#ref-veriplan">2025</a>) verifies sequential agent plans, but nobody has applied model checking or formal verification to graph-structured workflows. Properties like deadlock freedom (no circular waits in the task graph), guaranteed task completion (all paths lead to a terminal node), and Byzantine fault tolerance (the workflow produces correct output even if $k$ agents are compromised) are well-defined graph properties amenable to tools like TLA+ or SPIN. The gap between formal methods and agentic AI remains wide.</p>
<p><em>Conclusion.</em> The landscape I've described is one of rapid, somewhat fragmented progress. Graph-based orchestration has matured quickly — from concept to ICML/ICLR papers to production deployment in under two years. Agent security has grown explosively but remains fixated on content-level attacks. The critical missing piece is the bridge: applying the mature toolkit of graph adversarial robustness, GNN explainability, and structural risk optimization to the workflow graphs that increasingly define how agentic systems operate. The three papers at this intersection (G-Safeguard, NetSafe, MAMA) have opened the door, but the room beyond is largely empty.</p>
<!-- For researchers with expertise in GNN robustness and graph-based optimization, this is — I think — an unusually attractive moment to enter the field. -->

<h1 id="references">References</h1>
<p><a id="ref-llmcompiler"></a>
[1] Kim, S., Moon, S., Tabrizi, R., Lee, N., Mahoney, M.W., Keutzer, K., &amp; Gholami, A. (2024). <a href="https://arxiv.org/abs/2312.04511">An LLM Compiler for Parallel Function Calling</a>. <em>ICML 2024</em>.</p>
<p><a id="ref-stateflow"></a>
[2] Wu, J., Zhang, Y., Li, L., &amp; Wang, C. (2024). <a href="https://arxiv.org/abs/2403.11322">StateFlow: Enhancing LLM Task-Solving through State-Driven Workflows</a>.</p>
<p><a id="ref-dyntaskmas"></a>
[3] DynTaskMAS: A Dynamic Task Graph-driven Framework for Asynchronous Multi-Agent Systems. <em>ICAPS 2025</em>.</p>
<p><a id="ref-aflow"></a>
[4] Zhang, J., et al. (2025a). <a href="https://arxiv.org/abs/2410.10762">AFlow: Automating Agentic Workflow Generation</a>. <em>ICLR 2025</em>.</p>
<p><a id="ref-gptswarm"></a>
[5] Zhuge, M., et al. (2024). <a href="https://arxiv.org/abs/2402.16823">GPTSwarm: Language Agents as Optimizable Graphs</a>. <em>ICML 2024 (Oral)</em>.</p>
<p><a id="ref-locagent"></a>
[6] <a href="https://arxiv.org/abs/2503.09089">LocAgent: Graph-Guided LLM Agents for Code Localization</a>. <em>ACL 2025</em>.</p>
<p><a id="ref-langgraph"></a>
[7] <a href="https://github.com/langchain-ai/langgraph">LangGraph</a>. LangChain.</p>
<p><a id="ref-atlassian"></a>
[8] Atlassian Engineering. (2025). <a href="https://www.atlassian.com/blog/atlassian-engineering/how-rovo-embraces-multi-agent-orchestration">How Rovo Chat Embraces Multi-Agent Orchestration</a>.</p>
<p><a id="ref-macnet"></a>
[9] Qian, C., et al. (2025). <a href="https://openreview.net/forum?id=K3n5jPkrU6">Scaling Large Language Model-based Multi-Agent Collaboration (MacNet)</a>. <em>ICLR 2025</em>.</p>
<p><a id="ref-gdesigner"></a>
[10] Zhang, G., et al. (2025b). <a href="https://arxiv.org/abs/2410.11782">G-Designer: Architecting Multi-agent Communication Topologies via Graph Neural Networks</a>. <em>ICML 2025</em>.</p>
<p><a id="ref-gtd"></a>
[11] <a href="https://arxiv.org/abs/2510.07799">Dynamic Generation of Multi LLM Agents Communication Topologies with Graph Diffusion Models (GTD)</a>. 2025.</p>
<p><a id="ref-assemblecrew"></a>
[12] <a href="https://arxiv.org/abs/2507.18224">Assemble Your Crew: Automatic Multi-agent Communication Topology Design via Autoregressive Graph Generation</a>. 2025.</p>
<p><a id="ref-florabench"></a>
[13] Zhang, G., et al. (2025c). <a href="https://arxiv.org/abs/2503.11301">GNNs as Predictors of Agentic Workflow Performances (FLORA-Bench)</a>.</p>
<p><a id="ref-glow"></a>
[14] <a href="https://arxiv.org/abs/2512.15751">GLOW: Graph-Language Co-Reasoning for Agentic Workflow Performance Prediction</a>. 2025.</p>
<p><a id="ref-agentsmith"></a>
[15] Gu, X., et al. (2024). <a href="https://arxiv.org/abs/2402.08567">Agent Smith: A Single Image Can Jailbreak One Million Multimodal LLM Agents Exponentially Fast</a>. <em>ICML 2024</em>.</p>
<p><a id="ref-promptinfection"></a>
[16] Prompt Infection: LLM-to-LLM Prompt Injection within Multi-Agent Systems. 2024.</p>
<p><a id="ref-tamas"></a>
[17] <a href="https://arxiv.org/abs/2511.05269">TAMAS: Benchmarking Adversarial Risks in Multi-Agent LLM Systems</a>. 2025.</p>
<p><a id="ref-asb"></a>
[18] <a href="https://openreview.net/forum?id=V4y0CpX4hK">Agent Security Bench (ASB): Formalizing and Benchmarking Attacks and Defenses in LLM-based Agents</a>. <em>ICLR 2025</em>.</p>
<p><a id="ref-openhands"></a>
[19] Wang, X., et al. (2025a). <a href="https://arxiv.org/abs/2407.16741">OpenHands: An Open Platform for AI Software Developers as Generalist Agents</a>. <em>ICLR 2025</em>.</p>
<p><a id="ref-openhands-exfil"></a>
[20] Embrace The Red. (2025a). <a href="https://embracethered.com/blog/posts/2025/openhands-the-lethal-trifecta-strikes-again/">OpenHands and the Lethal Trifecta: Leaking Your Agent's Secrets</a>. 2025.</p>
<p><a id="ref-openhands-rce"></a>
[21] Embrace The Red. (2025b). <a href="https://embracethered.com/blog/posts/2025/openhands-remote-code-execution-zombai/">ZombAI Exploit with OpenHands: Prompt Injection to Remote Code Execution</a>. 2025.</p>
<p><a id="ref-invariant"></a>
[22] Invariant Labs. (2025). <a href="https://invariantlabs.ai/blog/enhancing-browser-agent-safety">Enhancing Browser Agent Safety with Guardrails</a>. 2025.</p>
<p><a id="ref-camel"></a>
[23] Debenedetti, E., et al. (2025). <a href="https://arxiv.org/abs/2503.18813">Defeating Prompt Injections by Design (CaMeL)</a>. <em>Google DeepMind</em>.</p>
<p><a id="ref-designpatterns"></a>
[24] Asan, E., et al. (2025). <a href="https://arxiv.org/abs/2506.08837">Design Patterns for Securing LLM Agents against Prompt Injections</a>.</p>
<p><a id="ref-trustagent"></a>
[25] Hua, W., et al. (2024). <a href="https://arxiv.org/abs/2402.01586">TrustAgent: Towards Safe and Trustworthy LLM-based Agents</a>. <em>EMNLP 2024</em>.</p>
<p><a id="ref-veriguard"></a>
[26] <a href="https://arxiv.org/abs/2510.05156">VeriGuard: Enhancing LLM Agent Safety via Verified Code Generation</a>. 2025.</p>
<p><a id="ref-agentspec"></a>
[27] AgentSpec: Customizable Runtime Safety for LLM Agents. <em>ICSE 2026</em>.</p>
<p><a id="ref-rtuning"></a>
[28] Zhang, H., et al. (2024). <a href="https://arxiv.org/abs/2311.09677">R-Tuning: Instructing Large Language Models to Say 'I Don't Know'</a>. <em>NAACL 2024 Outstanding Paper</em>.</p>
<p><a id="ref-overthinking"></a>
[29] <a href="https://arxiv.org/abs/2502.08235">The Danger of Overthinking: Examining the Reasoning-Action Dilemma in Agentic Tasks</a>. 2025.</p>
<p><a id="ref-gsafeguard"></a>
[30] Wang, K., Zhang, G., et al. (2025b). <a href="https://arxiv.org/abs/2502.11127">G-Safeguard: A Topology-Guided Security Lens and Treatment on LLM-based Multi-agent Systems</a>. <em>ACL 2025</em>.</p>
<p><a id="ref-netsafe"></a>
[31] Yu, Y., et al. (2025). <a href="https://arxiv.org/abs/2410.15686">NetSafe: Exploring the Topological Safety of Multi-agent Networks</a>. <em>ACL 2025</em>.</p>
<p><a id="ref-mama"></a>
[32] <a href="https://arxiv.org/abs/2512.04668">MAMA: Topology Matters: Measuring Memory Leakage in Multi-Agent LLMs</a>. 2024.</p>
<p><a id="ref-risksensitive"></a>
[33] <a href="https://arxiv.org/abs/2506.04632">Risk-Sensitive Agent Compositions</a>. 2025.</p>
<p><a id="ref-veriplan"></a>
[34] <a href="https://dl.acm.org/doi/10.1145/3706598.3714113">VeriPlan: Integrating Formal Verification and LLMs into End-User Planning</a>. <em>CHI 2025</em>.</p>
<p><a id="ref-bridging"></a>
[35] <a href="https://arxiv.org/abs/2510.03469">Bridging LLM Planning Agents and Formal Methods: A Case Study in Plan Verification</a>. 2025.</p>
<p><a id="ref-trustworthy-survey"></a>
[36] <a href="https://arxiv.org/abs/2503.09648">A Survey on Trustworthy LLM Agents: Threats and Countermeasures</a>. 2025.</p>
<p><a id="ref-security-survey"></a>
[37] <a href="https://www.sciencedirect.com/science/article/abs/pii/S1566253525010036">Security of LLM-based Agents Regarding Attacks, Defenses, and Applications: A Comprehensive Survey</a>. <em>Information Fusion</em>, 2025.</p>
<p><a id="ref-graph-augmented"></a>
[38] <a href="https://arxiv.org/abs/2507.21407">Graph-Augmented Large Language Model Agents: Current Progress and Future Prospects</a>. 2025.</p>
<p><a id="ref-graphs-meet"></a>
[39] <a href="https://arxiv.org/abs/2506.18019">Graphs Meet AI Agents: Taxonomy, Progress, and Future Opportunities</a>. 2025.</p>
        </div>

        <div class="post-disclaimer">
            <p><strong>Disclaimer.</strong> This post is a collection of my personal study notes. Opinions expressed here are my own. Much of the content is gathered and synthesized from existing literature — credit belongs to the original authors and their respective papers, which are cited throughout. AI tools were used to assist in the writing and editing process. As such, if you intend to reference or cite any material from this post, please verify the information against the original sources and take responsibility for its accuracy.</p>
        </div>

        <footer class="post-footer">
            <a href="index.html">&larr; all posts</a>
        </footer>
    </article>

    <footer class="site-footer">
        © Sun Changsheng
    </footer>
</body>
</html>